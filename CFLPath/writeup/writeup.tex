\documentclass[10pt,twocolumn]{article}

\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}

\pdfpagewidth 8.5in
\pdfpageheight 11in
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\topmargin}{-.25in}
\setlength{\textheight}{8in}

\theoremstyle{definition}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}

\newtheorem{definition}[theorem]{Definition}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{assumption}[theorem]{Assumption}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{problem}[theorem]{Problem}

\DeclareMathOperator*{\argmin}{arg\,min}

\begin{document}

\title{CFL Shortest Path for Minimum Model Problems}
\author{Osbert Bastani}
\date{\today}
\maketitle

\section{Introduction}

\noindent The Android platform is experiencing a proliferation of malware largely analagous to the early proliferation of malware on Windows systems. Even as new techniques are developed to detect malware applications, more sophisticated malware is developed to circumvent these protections. Ideally we would be able to provide provable guarantees about the safety of a given Android application. One promising approach is through the use of static analysis.

Static analysis techniques can be used to determine the flow of information through a program. A large number of malware applications are characterized by malicious flows of information, either from or to the Android device. For example:
\begin{enumerate}
\item a malware application that reads and sends stored passwords to a malicious web server has a flow from the stored passwords to the internet,
\item a malware application that displays advertisements for web pages, possibly scams, has a flow from the internet to the device display,
\item a malware application that calls premium phone numbers without the user's permission has a flow from the device to the dialed phone number.
\end{enumerate}
Detecting android malware would be greatly improved with a reliable understanding of information flow through the application. Unfortunately, performing static analyses on Android applications is greatly complicated by use of the extensive Android SDK, primarily because of the following problems:
\begin{enumerate}
\item the sheer size of the SDK means that static analysis does not scale well,
\item the Android SDK sometimes utilizes C or C++ libraries, which are more difficult to analyze.
\end{enumerate}

\noindent One solution is to replace the Android SDK with models that capture the relevant properties of the methods. For example, when analyzing information flow, the models should describe flow between arguments and to the return values.

Unfortunately, there is currently no way to automatically generate the models, so they must be provided by human auditors. Due to the number of methods in the Android SDK, and the evolving nature of the SDK, it is impractical for a small team of auditors to generate all the models by hand. Oftentimes, when trying to answer some query $q$ about the program, it suffices to implement only a small subset of missing models. Hence we have the following two problems:
\begin{problem}
\label{trueproblem}
Find the smallest set of models that must be implemented to have a good chance (according to some heuristic) to prove $q$ true.
\end{problem}
\begin{problem}
\label{falseproblem}
Find the smallest set of models that must be implemented to have a good chance (according to some heuristic) to prove $q$ false.
\end{problem}

\noindent The goal of this paper is to formalize and solve this problem for the case of finding information flow. For now, we will focus on Problem~\ref{trueproblem}.

\section{Background}

\noindent Here, we review the traditional flows-to graph for a program. Given a program $P$, let $F$ be the set of fields in $P$, and let $L$ be the context-free language generated by the following grammar:
\begin{enumerate}
\item a set of terminals
\begin{align*}
\Sigma=\{\text{alias}\}\cup\{\text{store}_f,\text{load}_f\}_{f\in F},
\end{align*}
\item the terminal symbol $T$,
\item the set of productions
\begin{align*}
\Pi=&\{T\to\epsilon,T\to\text{alias},T\to TT\}\\
&\cup\{T\to\text{load}_fT\text{store}_f\}_{f\in F},
\end{align*}
\noindent where $\epsilon$ is the empty string.
\end{enumerate}
\noindent Then the {\bf flows-to graph} $G$ for the program $P$ consists of the following data:
\begin{enumerate}
\item a set of vertices $V$, one for each reference in $P$,
\item a set of edges $E\subset V\times V\times\Sigma$.
\end{enumerate}
\noindent We think of $s\in\Sigma$ as a label on the edge $(x,y)\in V\times V$, so we write such an edge as $x\xrightarrow{s}y$. Note however that there can be multiple edges $(x,y)$, each with a different label. Given references $x$ and $y$, we include the following edges:
\begin{enumerate}
\item if there is an expression $y=x$, include the edge $x\xrightarrow{\text{alias}}y$,
\item if there is an expression $y.f=x$, include the edge $x\xrightarrow{\text{store}_f}y$,
\item if there is an expression $y=x.f$, include the edge $x\xrightarrow{\text{load}_f}y$.
\end{enumerate}
\noindent Then we have the following:

\begin{proposition}
Given a Java program with flows-to graph $G$, information flows from reference $x$ to reference $y$ only if there is a path $(e_1,...,e_n)$ from $x$ to $y$ such that the sequence $s_{e_1}...s_{e_n}\in L$, where $s_e\in\Sigma$ denotes the label on edge $e$. We call such a path a {\bf CFL path}.
\end{proposition}

\noindent This useful tool for capturing information flow through a program will be the basis for our analysis. We will augment the flows-to graph to handle the case of missing edges in the program, and then give an algorithm to find the minimum set of models according to some heuristic. Now we can state the information flow problem. Given a pair of references $($source$,$sink$)$, we would like to determine whether information can flow from source to sink. More precisely:
\begin{problem}
\label{flowproblem}
Given a program $P$ with flows-to graph $G=(V,E)$, and vertices $v_{\text{source}},v_{\text{sink}}\in V$, determine whether there exists a CFL path from $v_{\text{source}}$ to $v_{\text{sink}}$.
\end{problem}
When there are no missing models, this problem can be solved using a CFL reachability algorithm, as in~\cite{reps97}. We now turn to the issue of formulating this problem when the program has methods that are missing models.

\section{Information Flow with Missing Models}

\noindent We begin with a motivating example. Consider the following code:
\begin{algorithmic}
\State $x\gets$source
\State $y.f\gets x$
\State $z\gets$foo1($x$)
\State $w\gets$foo2($y$)
\State sink$\gets z$
\State sink$\gets w$
\end{algorithmic}
\noindent The associated graph $G$ is given in Figure~\ref{figure2}. It is clear that the following definitions of foo1 will induce information flow from the source to the sink:
\begin{algorithmic}
\Procedure{foo1}{x}
  \State\textbf{return} $x$
\EndProcedure
\end{algorithmic}
and similarly for foo2:
\begin{algorithmic}
\Procedure{foo2}{y}
	\State\textbf{return} $y.f$
\EndProcedure
\end{algorithmic}
\noindent In the remainder of this section we will develop an algorithm to handle the set of ``possible'' edges that can occur when a model is added. Since the set of such edges is technically infinite, we will need to introduce new algorithmic tools in order to do so.

\subsection{``Possible'' Edges}

\noindent In Figure~\ref{figure2}, we show the graph $G$ augmented with a pair of ``possible'' edges, represented by dashed arrows, that occur if foo1 and foo2 are defined as above. There are many other possible edges that can occur; the two shown happen to be the simplest edges that induce information flow. For example, we may have the following definition of foo2:
\begin{algorithmic}
\Procedure{foo2}{y}:
  \State{$t\gets y.f$};
  \State\textbf{return} $t.g$;
\EndProcedure
\end{algorithmic}
\noindent In this case, the flow would actually be $y\xrightarrow{\text{load}_f}t\xrightarrow{\text{load}_g}w$. To make this code valid, we would have to add a line such as $y.f.g=$source to the program source code, but this is not important for the purposes of this discussion. In general, the implementation of a method may introduce new vertices into the graph $G$. In order to handle these in a general way, we can instead add a single edge of the form $y\xrightarrow{\text{load}_f\text{load}_g}w$ that implicitly assumes the existence of the vertex $t$.

Now we are close to being able to precisely define the set of ``possible'' edges in the augmented graph. For example, consider the following process:
\begin{algorithmic}
\Procedure{GetPossibleEdges}{$P,\Lambda$}
  \State $E\gets$new Set()
	\For {expression $y=foo(x_1,...,x_n)$ in $P$}
		\If {$foo$ does not have a model}
	  	\State // add edges from $x_i$ to $x_j$
	  	\For {$1\le i\le n$, $1\le j\le n$, $l\in\Lambda$}
	  		\State $E$.add($x_i\xrightarrow{l}x_j$)
	  	\EndFor	  	
	  	\State // add edges from $x_i$ to $y$
	  	\For {$1\le i\le n$, $l\in\Lambda$}
	  		\State $E$.add($x_i\xrightarrow{l}y)$
	  	\EndFor
	  \EndIf
	\EndFor
	\State\textbf{return} $E$
\EndProcedure
\end{algorithmic}
\noindent Here $\Lambda$ is the set of allowed labels for ``possible'' edges. Our initial choice for $\Lambda$ is $\Lambda=\Sigma^*$, i.e. the set of all possible strings of elements in $\Sigma$. There are two issues with this choice:
\begin{enumerate}
\item the set $\Lambda=\Sigma^*$ is infinite,
\item the number of possible $l\in\Sigma^m$ is exponential in $m$ (with base $\#\Sigma=\#F$), so the complexity blows up even if the length of $l$ is bounded, i.e. we choose $\Lambda=\Sigma^m$ for some $m$.
\end{enumerate}

\noindent For now, we will solve the first issue by bounding the length of $l$ by $m$, so we focus for now on solving the second issue. First, it is clear that we can restrict the set of possible edges to a subset of $\Sigma^m$. Drawing again on our example, consider the edge $x\xrightarrow{\text{store}_f\text{load}_g}y$, which is equivalent to $x\xrightarrow{\text{store}_f}t\xrightarrow{\text{load}_g}y$. The points $x$ and $y$ are not connected in the context-free language sense since the $\text{store}_f$ and $\text{load}_g$ operations do not have matching fields. Any matching store and load operations must have matching fields.

Furthermore, consider the sequence $x\xrightarrow{\text{store}_f\text{load}_f}y$, which is equivalent to $x\xrightarrow{\text{store}_f}t\xrightarrow{\text{load}_f}y$. This indicates that the method foo1 would look like
\begin{algorithmic}
\Procedure{foo1}{x}
	\State$t.f\gets x$
	\State\textbf{return} t.f
\EndProcedure
\end{algorithmic}
But having $t.f$ is extraneous, and we could very well have just returned $x$ as before. Since we are only interested in the simplest possible models, we can delete the matching parenthesis. With some thought, we have the following proposition:
\begin{proposition}
\label{loadstore}
The values of $l$ that we need to consider are of the form
\begin{align*}
\text{load}_{f_1}...\text{load}_{f_n}\text{store}_{f_{n+1}}...\text{store}_{f_{n+m}}.
\end{align*}
\end{proposition}

\noindent However, while we have simplified the problem, there is still an exponential blowup in the number of edges that must be added. To fully solve the both issues, we will have to augment the language $L$ that we use.

\subsection{Augmented Flows-To Graph}

Here we redefine the language $L$ so that it can more flexibly handle edges representing missing models. The key idea is to note that along a ``possible'' edge, we can match any store and load opertions that occur before or after that edge. We would like to write an expression of the form
\begin{align*}
\text{load}_*...\text{load}_*\text{store}_*...\text{store}_*,
\end{align*}
where the $\text{store}_*$ edge matches any terminal $\text{load}_f$ and $\text{load}_*$ matches any terminal $\text{store}_f$. More precisely, we define the context-free language $L$ to be language generated by the following grammar:
\begin{enumerate}
\item the set of terminals
\begin{align*}
\Sigma=\{\text{alias},\text{store}_*,\text{load}_*\}\cup\{\text{store}_f,\text{load}_f\}_{f\in F},
\end{align*}
\item the terminal symbol $T$,
\item the set of productions
\begin{align*}
\Pi=&\{T\to\epsilon,T\to\text{alias},\\
&T\to TT,T\to\text{store}_*T\text{load}_*\}\\
&\cup\{T\to\text{store}_fT\text{load}_f,T\to\text{store}_f,\\
&T\to\text{store}_fT\text{load}_*,\\
&T\to\text{store}_*T\text{load}_f\}_{f\in F}.
\end{align*}
\end{enumerate}
Furthermore, we define the set
\begin{align*}
\lambda_k=
\begin{cases}
\{\text{alias}\},\text{ if }k=0\\
\{\text{store}_*,\text{load}_*\}^k,\text{ if }k\ge1.
\end{cases}
\end{align*}
By Lemma~\ref{loadstore}, we need only consider values
\begin{align*}
l\in\Lambda=\bigcup_{k=0}^\infty\lambda_k=(\text{store}_*)^*(\text{load}_*)^*.
\end{align*}
Here the $^*$ is the Kleene star operator. On some reflection, it is clear that an edge $x\xrightarrow{l\in\Lambda}y$ is equivalent to the set of edges
\begin{enumerate}
\item $x\xrightarrow{\epsilon}u\xrightarrow{\epsilon}v\xrightarrow{\epsilon}y$,
\item $u\xrightarrow{\text{store}_*}u$,
\item $v\xrightarrow{\text{load}_*}v$.
\end{enumerate}
This is because the new construction allows arbitrarily many loops $\text{store}_*$ followed by arbitrarily many loops $\text{load}_*$. Hence we have the following simple redefinition of $\text{getPossibleEdges}$:
\begin{algorithmic}
\Procedure{GetPossibleEdges}{$P$}
  \State $E\gets$new Set()
	\For {expression $y=foo(x_1,...,x_n)$ in $P$}
		\If {$foo$ does not have a model}
			\State // add edges from $x_i$ to $u_{x_i}$,
			\State // edges from $v_{x_i}$ to $x_i$ and $v_y$ to $y$,
			\State // and loops on $u_{x_i}$, $v_{x_i}$, and $v_y$
			\For {$1\le i\le n$}
				\State $E$.add($x_i\xrightarrow{\epsilon}u_{x_i}$)
				\State $E$.add($v_{x_i}\xrightarrow{\epsilon}x_i$)
				\State $E$.add($u_{x_i}\xrightarrow{\text{store}_*}u_{x_i}$)
				\State $E$.add($v_{x_i}\xrightarrow{\text{load}_*}v_{x_i}$)
			\EndFor
			\State $E$.add($v_y\xrightarrow{\epsilon}y$)
			\State $E$.add($v_y\xrightarrow{\text{load}_*}y$)
	  	\State // add edges from $u_{x_i}$ to $v_{x_j}$ to $v_y$
	  	\For {$1\le i\le n$, $1\le j\le n$}
	  		\State $E$.add($u_{x_i}\xrightarrow{\epsilon}v_{x_j}$)
	  	\EndFor
	  	\For {$1\le i\le n$}
	  		\State $E$.add($u_{x_i}\xrightarrow{\epsilon}v_y$)
	  	\EndFor
	  \EndIf
	\EndFor
	\State\textbf{return} $E$
\EndProcedure
\end{algorithmic}
\noindent Note here that we have included a further simplification, namely we require only one vertex $u_{x_i}$ and one vertex $v_{x_i}$ for each argument $x_i$ of a function call. This is acceptable since an edge going into $u_{x_i}$ can lead to any vertex $v_{x_j}$, so there is no need to have a distinct vertex for each flow $x_i\to x_j$. 

The {\bf augmented flows-to graph} $G$ is then the graph
\begin{enumerate}
\item a set of vertices $V$, one for each reference in $P$,
\item a set of edges $E\subset V\times V\times\Sigma$,
\item a set of ``possible'' edges $E'\subset V\times V\times\Sigma$.
\end{enumerate}
\noindent The sets $V$ and $E$ are defined as before, and the set $E'=\text{getPossibleEdges}(P)$. Now that we have a formalized the notion of missing models in the flows-to graph, we can turn to formalizing the missing models problem.

\subsection{Formalization}

\noindent We now formalize the missing models problem. We first need to define heuristic weights on each edge $e\in E'$ that give the relative likelihood of the edge $e$ appearing in the model. We want a function $h:\Sigma\to\mathbb{R}_+$, where $h(s)$ for $s\in\Sigma$ represents the heuristic weight of $s$. We then want to extend $h$ to paths $h:\Sigma^*\to\mathbb{R}_+$. For technical reasons we require that if $l=s_1...s_n$, then
\begin{align*}
h(l)\ge\max_{1\le i\le n}s_i.
\end{align*}
\noindent Following the notation of~\cite{knuth77}, we refer to the set of such functions as {\bf superior} functions. For our purposes, it will suffice to define
\begin{align*}
h(s_1...s_n)=h(s_1)+...+h(s_n).
\end{align*}
\noindent We also define $h$ on edges $e\in E\cup E'$ and on paths $p=(e_1,...,e_n)\in(E\cup E')^*$ by defining $h(e)=h(l_e)$, where $l_e\in\Sigma$ denotes the label on $e$, and $h(p)=h(e_1)+...+h(e_n)$.

Now that we have assigned heuristic weights to the edges, we can formalize the missing models problem. We want to find the smallest possible set of ``possible'' edges would induce flow from $v_{\text{source}}$ to $v_{\text{sink}}$. In other words, we want the CFL path $p=(e_1,...,e_n)$ from $v_{\text{source}}$ to $v_{\text{sink}}$ such that the heuristic weight of the path $h(e_1)+...+h(e_n)$ is minimized. Formally:
\begin{problem}
\label{cflshortestpath}
\noindent Given a program $P$ with augmented flows-to graph $G_m$, and vertices $v_{\text{source}},v_{\text{sink}}\in V$, find
\begin{align*}
\argmin_{p\in\text{paths}(v_{\text{source}},v_{\text{sink}})}h(p).
\end{align*}
\end{problem}

\noindent Returning to our example, we define the function $h$ by\noindent We define $h$ to be
\begin{align*}
h(s)=
\begin{cases}
1\text{ if }s\in\{\text{store}_*,\text{load}_*\}\\
0\text{ otherwise}
\end{cases}.
\end{align*}
\noindent We refer to this as the {\bf assignment depth heuristic}. Intuitively, this heuristic gives more weight to simpler models. Now it is clear that
\begin{align*}
h\left((\text{source},x,\text{alias}),(x,z,\text{alias}),(z,sink,\text{alias})\right)=0,
\end{align*}
and
\begin{align*}
h\left((\text{source},y,\text{alias}),(x,z,\text{alias}),(z,sink,\text{alias})\right)=0,
\end{align*}

\subsection{Reducing CFL Shortest Path to CFL Shortest String}

\noindent Here, we give reduce Problem~\ref{cflshortestpath} to a variation of the CFL shortest string problem:
\begin{problem}
\label{cflshorteststring}
\noindent Consider a context-free language $L$ generated by a grammar with terminals $\Sigma$, nonterminals $\Gamma$, and a weight function $h:\Sigma\to\mathbb{R}_+$, extend $h$ to $\Sigma^*$ by defining
\begin{align*}
h(s_1...s_n)=h(s_1)+...+h(s_n).
\end{align*}
\noindent The {\bf shortest string problem} for $L$ is to determine the function
\begin{align*}
\mu:\Sigma\cup\Gamma\to\mathbb{R}_+
\end{align*}
\noindent defined by
\begin{align*}
\mu(A)=\min_{l\in L:A\to l}h(l).
\end{align*}
\noindent Here, $A\to l$ means that there is some sequence of productions that generates the variable $A$ from the string $l$.
\end{problem}

\noindent The general idea is to find, for each $A\in \Sigma\cup V$, the shortest string $l\in L$ such that $A\to l$, where length is weighted by $h$. In order to reduce Problem~\ref{cflshortestpath} to Problem~\ref{cflshorteststring}, we will construct a new context-free grammar $(\Gamma_G,\Sigma_G,T_G,\Pi_G)$, that incorporates the structure of the graph $G$.

First, we define $\Sigma_G$ and $\Gamma_G$. For each $A\in\Gamma$, we include
\begin{align*}
\{A(u,v)\}_{u,v\in V}\subset\Gamma_G,
\end{align*}
and for each $s\in\Sigma$, we include
\begin{align*}
\{s(u,v)\}_{(u,v,s)\in E}\subset\Sigma_G.
\end{align*}

\noindent Next, we define $\Pi_G$. We require that the grammar be normalized, i.e. productions take the form $A\to MN$, $A\to M$, or $A\to\epsilon$. Any grammar can be transformed to a normalized grammar in linear time with a linear increase in the number of productions~\cite{reps97}. Once we have a normalized grammar for the language, we include the following productions in $\Pi_G$:
\begin{enumerate}
\item for each $A\to\epsilon\in\Pi$, we include
\begin{align*}
\{A(u,u)\to\epsilon\}_{u\in V},
\end{align*}
\item for each $A\to M\in\Pi$, $M\in\Sigma$ we include
\begin{align*}
\{A(u,v)\to M(u,v)\}_{u,v\in V},
\end{align*}
and if $M\in\Sigma$ we include
\begin{align*}
\{A(u,v)\to M(u,v)\}_{(u,v,M)\in E},
\end{align*}
\item for each $A\to MN\in\Pi$, if $M,N\in\Gamma$ we include
\begin{align*}
\{A(u,w)\to M(u,v)N(v,w)\}_{u,v,w\in V},
\end{align*}
if $M\in\Sigma,N\in\Gamma$ we include
\begin{align*}
\{A(u,w)\to M(u,v)N(v,w)\}_{(u,v,M)\in E,w\in V},
\end{align*}
if $M\in\Gamma,N\in\Sigma$ we include
\begin{align*}
\{A(u,w)\to M(u,v)N(v,w)\}_{u\in V,(v,w,N)\in E},
\end{align*}
if $M,N\in\Sigma$ we include
\begin{align*}
\{A(u,w)\to M(u,v)N(v,w)\}_{(u,v,M),(v,w,N)\in E},
\end{align*}
and we include
\begin{align*}
\{T_G\to T(u,v)\}_{u,v\in V}.
\end{align*}
\end{enumerate}
\noindent We refer to the language defined by the grammar $(\Gamma_G,\Sigma_G,T_G,\Pi_G)$ We then have the following lemma:
\begin{lemma}
Given a context-free language $L$ and a normalized grammar $(\Gamma,\Sigma,T,\Pi)$ defining it, and a graph $G=(V,E)$ with edges labeled by $\Sigma$, Problem~\ref{cflshortestpath} for $L$ and $G$ reduces to Problem~\ref{cflshorteststring} for $L_G$.
\end{lemma}

\begin{thebibliography}{9}

\bibitem{reps97}
	David Melski, Thomas Reps,
	``Incontrovertibility of set constraints and context-free language reachability,''
	\emph{Proc. of the ACM SIGPLAN Symp. on Part. Eval. and Sem.-Based Prog. Manip.},
	pp. 74-89 (1997).

\bibitem{knuth77}
	Donald Knuth,
	``A generalization of Dijkstra's algorithm,''
	\emph{Information Processing Letters}
	6(1) pp. 1-5 (1977).

\end{thebibliography}

\end{document}
